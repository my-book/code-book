#<div align = center>shell进程</div>
===================================

##一、进程简介

经常接触进程，那么什么是进程呢？

我记得看过一篇博文，描述的很形象，有兴趣的可以自己体会下：http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html

这里讲下比较专业的含义：

###进程

计算机基本动作被称为指令(instruction)。所谓的程序(program)，就是这样一系列指令的所构成的集合。通过程序，我们可以让计算机完成复杂的操作。程序大多数时候被存储为可执行的文件。这样一个可执行文件就像是一个菜谱，计算机可以按照菜谱作出可口的饭菜。
进程是程序的一个具体实现。进程是执行程序的过程，类似于按照食谱，真正去做菜的过程。同一个程序可以执行多次，每次都可以在内存中开辟独立的空间来装载，从而产生多个进程。不同的进程还可以拥有各自独立的IO接口 。

Linux下进程查看命令：$ps -eo pid,ppid,comm,cmd

计算机开机的时候，内核(kernel)只建立了一个init进程。Linux kernel并不提供直接建立新进程的系统调用。剩下的所有进程都是init进程通过fork机制建立的。新的进程要通过老的进程复制自身得到，这就是fork。fork是一个系统调用。进程存活于内存中。每个进程都在内存中分配有属于自己的一片空间 (address space)。当进程fork的时候，Linux在内存中开辟出一片新的内存空间给新的进程，并将老的进程空间中的内容复制到新的空间中，此后两个进程同时运行。

当子进程终结时，它会通知父进程，并清空自己所占据的内存，并在kernel里留下自己的退出信息(exit code，如果顺利运行，为0；如果有错误或异常状况，为>0的整数)。在这个信息里，会解释该进程为什么退出。父进程在得知子进程终结时，有责任对该子进程使用wait系统调用。这个wait函数能从kernel中取出子进程的退出信息，并清空该信息在kernel中所占据的空间。但是，如果父进程早于子进程终结，子进程就会成为一个孤儿(orphand)进程。孤儿进程会被过继给init进程，init进程也就成了该进程的父进程。init进程负责该子进程终结时调用wait函数。
当然，一个糟糕的程序也完全可能造成子进程的退出信息滞留在kernel中的状况（父进程不对子进程调用wait函数），这样的情况下，子进程成为僵尸（zombie）进程。当大量僵尸进程积累时，内存空间会被挤占。
我会有个疑问，可执行文件怎么生成的，可执行文件是如何执行的。可执行文件的生成，大体上是源码通过编译和运行生成的可执行文件。可执行文件执行会启动一个进程，

http://blog.chinaunix.net/uid-28281877-id-3751107.html 

###线程

线程是一种特殊的进程,是程序运行的基本执行单位。
当操作系统在执行一个程序时，会在系统中建立一个进程，而在进程中，必须至少创建一个主线程，作为程序运行的入口点。
线程可以共享进程的内存，并且拥有一个属于自己的内存空间，称为线程栈，是在建立线程时由系统分配，主要是用来保存线程内部的所使用的数据，
如线程执行函数中所定义的变量。在操作系统将进程分成多个线程后，这些线程可以在操作系统的管理下并发执行，从而大大提高了程序的运行效率。
虽然线程的执行从宏观上看是多个线程同时执行，但实际上这只是操作系统的障眼法。由于一块CPU同时只能执行一条指令，因此，在拥有一块CPU的计算机上不可能同时执行两个任务。而操作系统为了能提高程序的运行效率，在一个线程空闲时会撤下这个线程，并且会让其他的线程来执行，这种方式叫做线程调度。我们之所以从表面上看是多个线程同时执行，是因为不同线程之间切换的时间非常短，而且在一般情况下切换非常频繁。假设我们有线程A和B。在运行时，可能是A执行了1毫秒后，切换到B后，B又执行了1毫秒，然后又切换到了A，A又执行1毫秒。由于1毫秒的时间对于普通人来说是很难感知的，因此，从表面看上去就象A和B同时执行一样，但实际上A和B是交替执行的。

###shell进程相关命令

ps命令：查看进程信息

kill命令：杀掉进程命令
