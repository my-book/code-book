##<div align = center>shell介绍</div>
===========================

***

##一、引言

  最近的工作内容核心是DSL，俗称领域特定语言。涉及到的语言是shell和python，本部分只介绍shell
  
##二、shell历史

  了解操作系统的都知道，shell是人机交互的工具，完全是指令操作

###1.Bourne shell

  最早Ken Thompson设计Unix的时候，使用的是命令解释器，命令解释器接受用户的命令，然后解释他们并执行。

后来出现了Bourne shell(通称为sh)，顾名思义，就是一个叫Bourne shell创建的。对，它就是现在我们机器上面的/bin/sh这个可执行文件。这个老哥创建的sh一直沿用至今，现在的UNIX操作系统都配置有sh，而且各种新的shell都会向后兼容sh的语法。

Bourne shell 带来了：
```
脚本可以写在文件里被调用，比如sh a.sh可以执行a.sh里面的shell命令
可以交互或者非交互的方式调用
可以同步执行也可以异步执行
支持输入输出的pipeline，就是管道方式
支持输入输出的重定向，就是现在使用的> 和 >>
提供一系列内置命令
提供流程控制基本的函数和结构
弱类型变量，就是可以直接 a=1，不需要指定a为int
提供本地和全局的变量作用域
脚本执行前不需要编译
去掉goto功能
使用``进行命令执行替换
增加了for~do~done的循环
增加了case~in~esac的条件选择
文件描述符2>代表错误信息导出
```
###2.csh, ksh

Bourne老爷子创造的sh非常强大，后来引入的争议是Unix系统是C写的，为什么你的shell的语法不像C呢？然后Bill Joy就编写了C Shell(csh)。它用最类似C的语法来编写shell。后来csh演化成了tchsh，但是csh后面的路途就比较坎坷了，最终未能流行起来。但是现在比如在Mac系统上还保留csh。

Korn Shell(ksh)是1983年出现的，它向后兼容Bourne shell。同时吸取了C shell的一些优点，比如job control。

###3.bash

在1989年，现在最广泛使用的Bash出现了，它的全称叫做Bourne-Again shell。目的是为了与POSIX的标准保持一致，同时保持对sh的兼容。其实现在很多机器上的/bin/sh往往都链接到bash，我们以为我们是使用Bourne shell，实际上我们使用的是Bourne-Again shell

cat /etc/shells可以查看系统提供的已知shell

注意：这么多shell，到底怎么选择和使用呢，可以在建立用户时候，为每个用户指定默认的shell。可以通过echo $SHELL查看自己默认的shell，查看当前shell：echo $0

##三、linux介绍

&emsp;&emsp;![](images/shell-005.jpg)

##四、shell运行原理

shell作为一门语言，与其他语言有什么差别。我们指导编程语言大致分为两类，面向对象和面向过程，而shell是面向过程式语言，在面向对象的语言，要经过编译和链接的过程，最后才生成可执行文件

接下来介绍下shell的基本工作原理

shell是linux系统提供给用户的最重要的系统程序，不属于内核部分，而是核心之外，以用户态方式运行。其基本功能是解释并执行用户打入的各种命令，实现用户与Linux核心的接口。系统初启后，核心为每个终端用户建立一个进程去执行Shell解释程序。它的执行过程基本上按如下步骤：

(1)读取用户由键盘输入的命令行。

(2)分析命令，以命令名作为文件名，并将其它参数改造为系统调用execve( )内部处理所要求的形式。

(3)终端进程调用fork( )建立一个子进程。

(4)终端进程本身用系统调用wait4( )来等待子进程完成（如果是后台命令，则不等待）。当子进程运行时调用execve( )，子进程根据文件名（即命令名）到目录中查找有关文件（这是命令解释程序构成的文件），将它调入内存，执行这个程序（解释这条命令）。

(5)如果命令末尾有&号（后台命令符号），则终端进程不用系统调用wait4( )等待，立即发提示符，让用户输入下一个命令，转⑴。如果命令末尾没有&号，则终端进程要一直等待，当子进程（即运行命令的进程）完成处理后终止，向父进程（终端进程）报告，此时终端进程醒来，在做必要的判别等工作后，终端进程发提示符，让用户输入新的命令，重复上述处理过程。

Shell基本执行过程及父子进程之间的关系如图所示。具体详细介绍参考第几章

##五、shell执行方式

(1)source filename

作用:在当前bash环境下读取并执行FileName中的命令。该filename文件可以无"执行权限" 
注：该命令通常用命令“.”来替代。 

如：source bash_profile   . bash_profile两者等效。 
   source(或点)命令通常用于重新执行刚修改的初始化文档。 
   source命令(从 C Shell 而来)是bash shell的内置命令。 
   点命令，就是个点符号，(从Bourne Shell而来)。就是顺序的执行文件里的命令而已。

(2)、sh和bash命令用法：   sh FileName   bash FileName 
   作用:在当前相应的bash环境下新建一个子shell读取并执行FileName中的命令。该filename文件可以无"执行权限" 
   注：两者在执行文件时的不同，是分别用自己的shell来跑文件。 sh使用“-n”选项进行shell脚本的语法检查，使用“-x”选项实现shell脚本逐条语句的跟踪，可以巧妙地利用shell的内置变量增强“-x”选项的输出信息等。

(3)、./的命令用法：   ./FileName 
   作用:打开一个子shell来读取并执行FileName中命令。 
   该文件必须有可执行的权限。 
   注：运行一个shell脚本时会启动另一个命令解释器. 
   每个shell脚本有效地运行在父shell(parent shell)的一个子进程里. 这个父shell是指在一个控制终端或在一个xterm窗口中给你命令指示符的进程.
   shell脚本也可以启动他自已的子进程.这些子shell(即子进程)使脚本并行地，有效率地地同时运行脚本内的多个子任务.
   脚本里的变量设置在父进程中无效。脚本中的export仅仅作用于该脚本及其子脚本位置变量参数在向脚本传递参数时，可以使用此位置变量来获取参数。他们分别是：
```   
   $0:脚本名字。此变量包含地址，可以使用basename
   $0获得脚本名称。 
   $1:第一个参数 
   $2,$3,$4,$5,...一次类推。
   特定变量参数 
   一些脚本运行的相关控制信息 
   $# 传递到脚本的参数个数 
   $* 以一个单字符串显示所有向脚本传递的参数 
   $$ 脚本运行的ID号 
   $! 后台运行的最后一个进程的ID号 
   $@ 与$#相同，但是使用时加引号，并在引号中返回每个参数。 
   $- 显示shell使用的当前选项。 
   $? 显示最后命令的推出状况。0表示没有错误。
```

##六、source filename 与 sh filename 及./filename执行脚本的区别在那里呢？
   
1.当shell脚本具有可执行权限时，用sh filename与./filename执行脚本是没有区别得。./filename是因为当前目录没有在PATH中，所有"."是用来表示当前目录的。

2.sh filename 重新建立一个子shell，在子shell中执行脚本里面的语句，该子shell继承父shell的环境变量，但子shell新建的、改变的变量不会被带回父shell，除非使用export。

3.source filename：这个命令其实只是简单地读取脚本里面的语句依次在当前shell里面执行，没有建立新的子shell。那么脚本里面所有新建、改变变量的语句都会保存在当前shell里面。

举例说明：

1.新建一个test.sh脚本，内容为:A=1

2.然后使其可执行chmod +x test.sh

3.运行sh test.sh后，echo $A，显示为空，因为A=1并未传回给当前shell

4.运行./test.sh后，也是一样的效果

5.运行source test.sh 或者 . test.sh，然后echo $A，则会显示1，说明A=1的变量在当前shell中?


