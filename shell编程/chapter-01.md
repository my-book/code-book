#shell介绍
===========================

***

##引言

  最近的工作内容核心是DSL，俗称领域特定语言。涉及到的语言是shell和python，本部分只介绍shell
  
##shell历史

  了解操作系统的都知道，shell是人机交互的工具，完全是指令操作

###Bourne shell

  最早Ken Thompson设计Unix的时候，使用的是命令解释器，命令解释器接受用户的命令，然后解释他们并执行。

后来出现了Bourne shell(通称为sh)，顾名思义，就是一个叫Bourne shell创建的。对，它就是现在我们机器上面的/bin/sh这个可执行文件。这个老哥创建的sh一直沿用至今，现在的UNIX操作系统都配置有sh，而且各种新的shell都会向后兼容sh的语法。

Bourne shell 带来了：
```
脚本可以写在文件里被调用，比如sh a.sh可以执行a.sh里面的shell命令
可以交互或者非交互的方式调用
可以同步执行也可以异步执行
支持输入输出的pipeline，就是管道方式
支持输入输出的重定向，就是现在使用的> 和 >>
提供一系列内置命令
提供流程控制基本的函数和结构
弱类型变量，就是可以直接 a=1，不需要指定a为int
提供本地和全局的变量作用域
脚本执行前不需要编译
去掉goto功能
使用``进行命令执行替换
增加了for~do~done的循环
增加了case~in~esac的条件选择
文件描述符2>代表错误信息导出
```
###csh, ksh

Bourne老爷子创造的sh非常强大，后来引入的争议是Unix系统是C写的，为什么你的shell的语法不像C呢？然后Bill Joy就编写了C Shell(csh)。它用最类似C的语法来编写shell。后来csh演化成了tchsh，但是csh后面的路途就比较坎坷了，最终未能流行起来。但是现在比如在Mac系统上还保留csh。

Korn Shell(ksh)是1983年出现的，它向后兼容Bourne shell。同时吸取了C shell的一些优点，比如job control。

###bash

在1989年，现在最广泛使用的Bash出现了，它的全称叫做Bourne-Again shell。目的是为了与POSIX的标准保持一致，同时保持对sh的兼容。其实现在很多机器上的/bin/sh往往都链接到bash，我们以为我们是使用Bourne shell，实际上我们使用的是Bourne-Again shell

cat /etc/shells可以查看系统提供的已知shell

注意：这么多shell，到底怎么选择和使用呢，可以在建立用户时候，为每个用户指定默认的shell。可以通过echo $SHELL查看自己默认的shell，查看当前shell：echo $0

##shell运行原理

shell作为一门语言，与其他语言有什么差别。我们指导编程语言大致分为两类，面向对象和面向过程，而shell是面向过程式语言，在面向对象的语言，要经过编译和链接的过程，最后才生成可执行文件

接下来介绍下shell的基本工作原理

shell是linux系统提供给用户的最重要的系统程序，不属于内核部分，而是核心之外，以用户态方式运行。其基本功能是解释并执行用户打入的各种命令，实现用户与Linux核心的接口。系统初启后，核心为每个终端用户建立一个进程去执行Shell解释程序。它的执行过程基本上按如下步骤：

(1)读取用户由键盘输入的命令行。

(2)分析命令，以命令名作为文件名，并将其它参数改造为系统调用execve( )内部处理所要求的形式。

(3)终端进程调用fork( )建立一个子进程。

(4)终端进程本身用系统调用wait4( )来等待子进程完成（如果是后台命令，则不等待）。当子进程运行时调用execve( )，子进程根据文件名（即命令名）到目录中查找有关文件（这是命令解释程序构成的文件），将它调入内存，执行这个程序（解释这条命令）。

(5)如果命令末尾有&号（后台命令符号），则终端进程不用系统调用wait4( )等待，立即发提示符，让用户输入下一个命令，转⑴。如果命令末尾没有&号，则终端进程要一直等待，当子进程（即运行命令的进程）完成处理后终止，向父进程（终端进程）报告，此时终端进程醒来，在做必要的判别等工作后，终端进程发提示符，让用户输入新的命令，重复上述处理过程。

Shell基本执行过程及父子进程之间的关系如图所示。具体详细介绍参考第几章

##shell执行方式





